<?php ## использование статических членов класса
    class Counter
    {
        // Скрытый статический член класса - общий для всех объектов
        private static $count = 0;
        // конструктор увеличивает счётчик на 1. обратите внимание
        // на синтаксис доступа к статическим переменным класса!
        public function __construct() { self::$count++; }
        // деструктор же уменьшает
        public function __destruct() { self::$count--;}
        // статическая функция, возвращает счётчик объектов
        public static function getCount() { return self::$count; }
        // из за private можно только получить значение счётчика
    }

    // создаём 6 объектов
    for ($obj = [], $i = 0; $i < 6; $i++)
        $obj[] = new Counter();
        // статические функции можно вызывать точно так же, как будто 
        // бы это обычный метод объекта. При этом $this всё равно не 
        // передаётся, он игнорируется
        echo " Сейчас существует {$obj[0]->getCount()} объектов. <br />";
        // удаляем один объект
        $obj[5] = null;
        // счётчик объектов уменьшился
        echo "А теперь - {$obj[0]->getCount()} объектов. <br />";
        // удаляем все объекты
        $obj = [];
        // другой способ вызова статического метода - с указанием класса.
        // этто очень похоже не вызов функции из билиотеки
        echo "Под конец осталось - ".Counter::getCount()." объектов. <br />";
        ?>